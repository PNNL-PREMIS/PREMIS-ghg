---
title: "proximity_results"
author: "SP"
output: html_document
---

### `r Sys.Date()`

```{r helper-functions, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}

library(MASS)
library(nlme) # 3.1.137
library(drake)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())
library(broom)
library(lubridate)
library(piecewiseSEM)

# Define functions

# Calcuate basal area (m2) from tree diameter (cm)
calc_BA <- function(DBH) {
  DBH_m <- DBH / 100 # cm to meters
  radius <- DBH_m / 2 # we want the radius to compute the area
  radius ^ 2 * pi # basal area area calculation
}

# Compute the sum of per-tree basal area within a certain distance (to respiration collars)
basal_area_sum <- function(data, distance) {
  data %>% 
    filter(Distance_m <= distance) %>% 
    group_by(Collar) %>% 
    summarise(n_trees = n(), 
              BA_m2 = round(sum(BA_sqm, na.rm = TRUE), digits = 3), 
              dist = distance) %>% 
    replace_na(list(n_trees = 0, BA_m2 = 0.0))  # if no trees within distance, zero
}

# Fit the main statistical model testing for effect of basal area (BA) on soil respiration
run_model <- function(dat, model_type) {
  
  if(any(is.na(dat))) {
    stop("Can't have any NAs in run_model data")
  }
  
  if(model_type == "linear") {
    mod_full <- lm(log(Flux) ~ T5 * BA_m2 + T20 * BA_m2 + SMoisture + I(SMoisture ^ 2),
                   data = dat)
    mod_no_BA <- lm(formula = log(Flux) ~ T5 + T20 + SMoisture + I(SMoisture ^ 2), data = dat)
  } else if(model_type == "lme") {
    mod_full <- nlme::lme(log(Flux) ~ T5 * BA_m2 + T20 * BA_m2 + SMoisture + I(SMoisture ^ 2),
                          data = dat,
                          # allow for random variation across sites
                          random = ~ 1 | Site,
                          method = "ML") # because we're doing stepAIC below
    mod_no_BA <- nlme::lme(log(Flux) ~ T5 + T20 + SMoisture + I(SMoisture ^ 2),
                           data = dat, random = ~ 1 | Site, method = "ML")
  } else {
    stop("Unknown model type ", model_type)
  }
  
  # Remove non-significant variables and return
  mod_reduced <- stepAIC(mod_full, direction = "both", trace = 0)
  list(full_model = mod_full, reduced_model = mod_reduced, mod_no_BA = mod_no_BA)
}

# Produce summaries and plots for the run_model() objects
model_stats <- function(mods, dat) {
  
  print(piecewiseSEM::rsquared(mods$full_model))
  
  # Plot correlation between BA and the residuals of the model
  # WITHOUT basal area included
  dat$no_BA_residuals <- residuals(mods$mod_no_BA)
  p <- ggplot(dat, aes(no_BA_residuals, BA_m2, color = Site)) + 
    geom_point(alpha = 0.75) + 
    geom_smooth(method = "lm", se = FALSE) +
    geom_smooth(method = "lm", group = 1, color = "black") +
    xlab(expression(Residual~(µmol~m^-2~s^-1))) +
    ylab(expression(Basal~area~(m^2)))
  print(p)
  
  m_reduced <- mods$reduced_model
  
  print(summary(m_reduced))
  print(car::Anova(m_reduced, type = "III"))   # NOT stats::anova()!
  plot(m_reduced)
}

# Helper function to calculate sample size
# flux is a vector of fluxes; delta a fraction 0-1; power = 1-beta, also 0-1
# This follows Davidson et al. (2002)
sample_n <- function(flux, delta, power) {
  (qt(1 - (1 - power) / 2, df = length(flux) - 1) * sd(flux) / (mean(flux) * delta)) ^ 2
}
```


```{r setup, echo = FALSE}
tree_data <- readd("tree_data")
prox_data <- readd("prox_data")

prox_data %>%
  select(-Date) %>%
  left_join(tree_data, by = c("Site", "Plot", "Tag"), na_matches = "never") %>%
  # Replace DBH with recorded value for non-tagged trees
  mutate(DBH_cm = if_else(is.na(Tag), No_tag_DBH, DBH_cm),
         Species_code = if_else(is.na(Tag), No_tag_species, Species_code),
         BA_sqm = calc_BA(DBH_cm)) -> # Compute basal area for each tree
  tree_prox_data
```


### Prep work: compute cumulative basal area for each collar
```{r basal-area-fig, fig.width = 9, echo = FALSE}

# Calculate cumulative basal area at each distance 
BA_dat <- list()
for (i in 1:max(tree_prox_data$Distance_m, na.rm = TRUE)) {
  tree_prox_data %>% 
    filter(Distance_m <= i) %>% 
    group_by(Collar) %>% 
    summarise(n_trees = n(), 
              BA_m2 = sum(BA_sqm, na.rm = TRUE), 
              dist = i) -> #%>%
    #    complete(dist = i, Collar, fill = list(BA_m2 = 0, n_trees = 0))->
    BA_dat[[i]]
}

# Combine and complete data (in particular, adding values for 0 m)
bind_rows(BA_dat) %>% 
  complete(Collar, dist = c(0:max(tree_prox_data$Distance_m, na.rm = TRUE)),
           fill = list(BA_m2 = 0, n_trees = 0)) ->
  BA_dat_complete

# ...and plot
BA_dat_complete %>% 
  ggplot(aes(x = dist, y = BA_m2, group = Collar, color = n_trees)) + 
  geom_line(size = 1) +
  scale_colour_gradientn(colours = topo.colors(9)) +
  ggtitle("Figure 2") +
  labs(x = "Radial distance from collar (m)", 
       y = expression(Basal~Area~(m^2)), 
       color = "Number \nof Trees")

```


## Table 1 - site info
```{r site-info, echo = FALSE, warning = FALSE, message = FALSE}
# BA by percentage
tree_data %>%
  group_by(Site, Salinity, Species) %>%
  summarise(n = n(),
            BA_species = sum(calc_BA(DBH_cm), na.rm = TRUE)) %>%
  mutate(BA_p = BA_species/sum(BA_species) * 100) ->
  BA_p

##SP TO ADD COMMENTS AND CONSTANTS FOR CLARITY
tree_data %>% 
  group_by(Salinity, Elevation) %>% 
  summarise(n = n(), 
            Plot_area_m2 = mean(Plot_area_m2), 
            `BA (m2/ha)` = sum(calc_BA(DBH_cm), na.rm = TRUE) / 
              mean(Plot_area_m2) * 10000) %>% 
  mutate(`Trees (/ha)` = n / Plot_area_m2 * 10000) %>% 
  summarise(tree_mean = mean(`Trees (/ha)`) %>% round(1), 
            tree_sd = sd(`Trees (/ha)`) %>% round(1), 
            BA_mean = mean(`BA (m2/ha)`) %>% round(1), 
            BA_sd = sd(`BA (m2/ha)`) %>% round(1)) ->
  tabledata

# Site info
tabledata$tree_mean <- round(tabledata$tree_mean, digits = 1)
tabledata$tree_sd <- round(tabledata$tree_sd, digits = 1)
tabledata$BA_mean <- round(tabledata$BA_mean, digits = 1)
tabledata$BA_sd <- round(tabledata$BA_sd, digits = 1)
tabledata$Salinity <- sub("Salinity H", "GCReW", tabledata$Salinity)
tabledata$Salinity <- sub("Salinity M", "Canoe Shed", tabledata$Salinity)
tabledata$Salinity <- sub("Salinity L", "North Branch", tabledata$Salinity)
# tabledata$Soil_Type[1] <- "Collington-Wist complex; Collington and Annapolis soils"
# tabledata$Soil_Type[2] <- "Annapolis fine sandy loam"
# tabledata$Soil_Type[3] <- "Collington and Annapolis soils; Collington, Wist, and Westphalia soils"

tabledata %>% 
  unite(col = 'Trees (/ha)', tree_mean, tree_sd, sep = " ± ") %>%
  unite(col = 'BA (m2/ha)', BA_mean, BA_sd, sep = " ± ") %>%
  knitr::kable(digits = 1, format = "html", 
               col.names = c("Site", "Trees (/ha)", "BA (m2/ha)")) %>%
  kableExtra::kable_styling(c("striped", "bordered"), full_width = FALSE)
```


## Flux over time figure for control collars
```{r co2_time, echo = FALSE, warning = FALSE, fig.width = 8}
licor_daily_data <- readd("licor_daily_data")

# s.d. is based on successive measurements at same collar
licor_daily_data %>% 
  filter(!is.na(meanFlux), !is.na(sdFlux)) %>% 
  filter(Group == "Control") %>%
  ggplot(aes(x = Timestamp, y = meanFlux, group = Collar)) +
  geom_point() +
  geom_smooth(aes(group = Dest_Site), color = "dodgerblue", se = FALSE) +
  facet_grid(~Dest_Site) +
  ggtitle("Figure 3") +
  labs(x = "Date", 
       y = expression(Flux~(µmol~CO[2]~m^-2~s^-1))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

## Power calculation

Calculate sampling requirements based on the standard deviation of Rs, the desired 
power of the test, and the allowable delta (fraction difference from the true mean value):

```{r power, echo=FALSE}
results_list <- list()
for(delta_fraction in c(0.05, 0.10, 0.25, 0.5)) {
  for(power in c(seq(0.1, 0.9, by = 0.1), 0.95)) {
    licor_daily_data %>%
      filter(!is.na(meanFlux)) %>% 
      group_by(Dest_Salinity, Dest_Elevation) %>%
      summarise(n = sample_n(meanFlux, delta = delta_fraction, power = power)) %>% 
      mutate(delta = delta_fraction, power = power) ->
      results_list[[paste(delta_fraction, power)]]
  }
}
bind_rows(results_list) %>% 
  group_by(delta, power) %>% 
  summarise(n_sd = ceiling(sd(n)), n = ceiling(mean(n))) %>% 
  ungroup %>% 
  mutate(delta_fac = as.factor(delta)) %>% 
  filter(!is.na(n)) -> 
  results

ggplot(results, aes(power, n, color = factor(delta), group = delta)) +
  geom_line() + 
  geom_ribbon(aes(ymin = n - n_sd, ymax = n + n_sd, fill = factor(delta)),
              alpha = 0.25, color = NA) +
  scale_color_discrete("Delta") +
  xlab(expression(Power~(1-beta))) + ylab("N required") +
  guides(fill = FALSE) +
  ggtitle("Power analysis")

# Make a nice table
results %>% 
  filter(power >= 0.5) %>% 
  mutate(N = paste(floor(n), floor(n_sd), sep = " ± ")) %>% 
  select(delta, power, N) %>% 
  spread(power, N) %>% 
  kableExtra::kable() %>%
  kableExtra::kable_styling(c("striped", "bordered"), full_width = FALSE)
```


## Model Results {.tabset .tabset-fade .tabset-pills}

### Hypothesis I - BA strong effect within 5 meters 
```{r test-h1, echo = FALSE, warning = FALSE}
# Filter Licor data for only true control collars and screen out bad SM data
MODEL_TYPE <- "lme"
TEST_DISTANCE <- 5

readd("licor_data") %>% 
  filter(Experiment == "Control", is.na(Notes)) %>% 
  # Filter out bad soil moisture and flux readings
  filter(SMoisture > 0, SMoisture < 1,
         Flux > 0) ->
  control_cols

# Calculate basal area within 5 m
BA5 <- basal_area_sum(tree_prox_data, distance = TEST_DISTANCE)

filter_NAs <- function(x) {
  x %>% filter(!is.na(Flux), !is.na(T5), !is.na(T20), !is.na(SMoisture), !is.na(BA_m2))
}

# Join the respiration data with the BA proximity data; this is main analysis dataset
control_cols %>% 
  left_join(BA5, by = "Collar") %>% 
  mutate(Timestamp = ymd_hms(Timestamp)) %>% 
  select(Timestamp, Flux, T5, T20, SMoisture, BA_m2, Site = Dest_Site) %>% 
  na.omit -> 
  control_cols_5m

# Run the main analysis
h1 <- run_model(control_cols_5m, model_type = MODEL_TYPE)
model_stats(h1, control_cols_5m)
```

### Hypothesis II - growing vs. dormant season
```{r test-h2, echo = FALSE, warning = FALSE}
# Filter true controls for growing season
GS_MONTHS <- 4:10  # growing season months, i.e. April-October
control_cols_5m$Growing_season <- month(control_cols_5m$Timestamp) %in% GS_MONTHS

growing_flux <- filter(control_cols_5m, Growing_season)
h2g <- run_model(growing_flux, model_type = MODEL_TYPE)
print("Growing Season")
model_stats(h2g, growing_flux)

# Filter true controls for dormant season
dormant_flux <- filter(control_cols_5m, !Growing_season)
h2d <- run_model(dormant_flux, model_type = MODEL_TYPE)

print("Dormant Season")
model_stats(h2d, dormant_flux)
```

### Hypothesis III - moisture-limited times
```{r test-h3, echo = FALSE, warning = FALSE}

## replace with actual variable name once drake is working
control_cols_5m$SM_bin <- cut(control_cols_5m$SMoisture, breaks = 3, label = FALSE)

low_i <- which(control_cols_5m$SM_bin == 1)

## Filter true controls for the bottom and top 33% soil moisture values
m_low <- control_cols_5m[low_i, ] %>% filter_NAs
h3l <- run_model(m_low, model_type = MODEL_TYPE)

print("Low Moisture")
model_stats(h3l, m_low)

high_i <- which(control_cols_5m$SM_bin == 3)
m_high <- control_cols_5m[high_i, ] %>% filter_NAs
h3h <- run_model(m_high, model_type = MODEL_TYPE)

print("High Moisture")
model_stats(h3h, m_high)
```

## Sensitivity test - BA significance with distance
```{r sensitivity, echo = FALSE, warning = FALSE, fig.width = 9}

sens_output <- list()
BA_output <- list()
# Loop through the range of distances we measured and run 
# our basal area/respiration test at each
for (i in seq.int(2, max(tree_prox_data$Distance_m, na.rm = TRUE))) {
  BA <- basal_area_sum(tree_prox_data, i)
  control_cols %>% 
    left_join(BA, by = "Collar") %>%
    select(Timestamp, Flux, T5, T20, SMoisture, BA_m2, Site = Dest_Salinity) %>% 
    na.omit ->
    dat
  mods <- run_model(dat, model_type = MODEL_TYPE)
  smry <- car::Anova(mods$reduced_model, type = "III")
  
  # linear and lme models and car::Anova return differently-named p-value columns;
  # rename for consistency
  names(smry)[ncol(smry)] <- "p-value"
  smry$Term = rownames(smry)
  sens_output[[as.character(i)]] <- as_tibble(smry)
}

bind_rows(sens_output, .id = "Distance") %>%
  filter(grepl("BA_m2", Term)) %>%
  mutate(Distance = as.integer(Distance)) %>%
  print %>%
  ggplot(aes(Distance, `p-value`, color = Term)) + 
  geom_line(size = 1) + 
  geom_point(size = 2.5) +
  geom_vline(xintercept = TEST_DISTANCE, linetype = 2) +
  geom_hline(yintercept = 0.05, linetype = 2) +
  xlab("Radial distance from collar (m)") + 
  ylab("P-value") +
  scale_color_discrete(labels = c("BA", "BA:T20", "BA:T5")) +
  scale_y_log10()
```
