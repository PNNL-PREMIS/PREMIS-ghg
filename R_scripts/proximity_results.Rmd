---
title: "proximity_results"
author: "SP"
date: "October 24, 2018"
output: html_document
---

```{r, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}

library(nlme) # 3.1.137
#library(lme4) # 1.1-19
library(drake)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())
library(broom)
library(lubridate)

# Define functions

# Calcuate basal area (m2) from tree diameter (cm)
calc_BA <- function(DBH) {
  DBH_m <- DBH / 100 # cm to meters
  radius <- DBH_m /2 # we want the radius to compute the area
  BA <- radius ^2 * pi # area calculation
  return(BA)
}
# Compute the sum of per-tree basal area within a certain distance (to respiration collars)
basal_area_sum <- function(data, distance) {
  data %>% 
    filter(Distance_m <= distance) %>% 
    group_by(Collar) %>% 
    summarise(n_trees = n(), 
              BA_m2 = round(sum(BA_sqm, na.rm = TRUE), digits = 3), 
              dist = distance) %>% 
    replace_na(list(n_trees = 0, BA_m2 = 0.0))  # if no trees within distance, zero
}

# Fit the main statistical model testing for effect of basal area (BA) on soil respiration
run_model <- function(flux, T5, T20, SM, BA, site, model_type) {
  # Ensure that there are no NAs in our dataset
  dat <- tibble(flux, T5, T20, SM, BA, site) %>% na.omit
  
  if(model_type == "linear") {
    mod_full <- lm(log(flux) ~ T5 * BA + T20 * BA + SM + I(SM ^ 2) + BA, data = dat)
  } else if(model_type == "lme") {
    mod_full <- nlme::lme(log(flux) ~ T5 * BA + T20 * BA + SM + I(SM ^ 2) + BA, 
                          data = dat,
                          # allow for random variation across sites
                          random = ~ 1 | site,
                          method = "ML" # because we're doing stepAIC below
    )
  } else {
    stop("Unknown model type ", model_type)
  }
  
  # Remove non-significant variables
  mod_reduced <- stepAIC(mod_full, direction = "both", trace = 0)
  
  # Return models
  list(full_model = mod_full, reduced_model = mod_reduced)
}

# This function takes run_model() objects and produces summaries and plots
model_stats <- function(mods) {
  
  m_reduced <- mods$reduced_model
  summary(m_reduced)
  anova(m_reduced)
  plot(m_reduced)
  data$prediction <- predict(m_reduced)

  ggplot(data, aes(Timestamp, Flux)) +
    geom_point() +
    geom_line(aes(y = exp(prediction))) +
    facet_wrap(~Collar) +
    ggtitle(MODEL_TYPE)
  
  #whatever other plots we want to make
}

```


```{r joindata}

tree_data <- readd("tree_data")
prox_data <- readd("prox_data")

prox_data %>%
  select(-Date) %>% 
  mutate(Tag = as.character(Tag)) %>%
  left_join(tree_data, by = c("Site", "Plot", "Tag"), na_matches = "never") %>%
  # Replace DBH with recorded value for non-tagged trees
  mutate(DBH_cm = if_else(is.na(Tag), No_tag_DBH, DBH_cm),
         Species_code = if_else(is.na(Tag), No_tag_species, Species_code),
         BA_sqm = calc_BA(DBH_cm)) -> # Compute basal area for each tree
  tree_prox_data

```


### Prep work: compute cumulative basal area for each collar
```{r, fig.width = 9}

# Calculate cumulative basal area at each distance 
BA_dat <- list()
for (i in 1:max(tree_prox_data$Distance_m)) {
  tree_prox_data %>% 
    filter(Distance_m <= i) %>% 
    group_by(Collar) %>% 
    summarise(n_trees = n(), 
              BA_m2 = sum(BA_sqm, na.rm = TRUE), 
              dist = i) -> #%>%
    #    complete(dist = i, Collar, fill = list(BA_m2 = 0, n_trees = 0))->
    BA_dat[[i]]
}

# Combine and complete data (in particular, adding values for 0 m)
bind_rows(BA_dat) %>% 
  complete(Collar, dist = c(0:max(tree_prox_data$Distance_m)),
           fill = list(BA_m2 = 0, n_trees = 0)) %>% 
  # ...and plot
  ggplot(aes(x = dist, y = BA_m2, group = Collar, color = n_trees)) + 
  geom_line(size = 1) +
  scale_colour_gradientn(colours = topo.colors(9)) +
  ggtitle("Cumulative Basal Area") +
  labs(x = "Radial distance from collar (m)", 
       y = expression(Basal~Area~(m^2)), 
       color = "Number \nof Trees")

```


### Table 1 - site info
```{r, echo = FALSE, warning = FALSE, message = FALSE}
##SP TO ADD COMMENTS AND CONSTANTS FOR CLARITY
tree_data %>% 
  group_by(Site, Salinity, Elevation) %>% 
  summarise(n = n(), 
            Plot_area_m2 = mean(Plot_area_m2), 
            `BA (m2/ha)` = sum(calc_BA(DBH_cm), na.rm = TRUE) / 
              mean(Plot_area_m2) * 10000) %>% 
  mutate(`Trees (/ha)` = n / Plot_area_m2 * 10000) %>% 
  summarise(tree_mean = mean(`Trees (/ha)`) %>% round(1), 
            tree_sd = sd(`Trees (/ha)`) %>% round(1), 
            BA_mean = mean(`BA (m2/ha)`) %>% round(1), 
            BA_sd = sd(`BA (m2/ha)`) %>% round(1)) ->
  tabledata

# Site info
tabledata$tree_mean <- round(tabledata$tree_mean, digits = 1)
tabledata$tree_sd <- round(tabledata$tree_sd, digits = 1)
tabledata$BA_mean <- round(tabledata$BA_mean, digits = 1)
tabledata$BA_sd <- round(tabledata$BA_sd, digits = 1)
tabledata$Salinity <- sub("Salinity H", "High", tabledata$Salinity)
tabledata$Salinity <- sub("Salinity M", "Medium", tabledata$Salinity)
tabledata$Salinity <- sub("Salinity L", "Low", tabledata$Salinity)
# tabledata$Soil_Type[1] <- "Collington-Wist complex; Collington and Annapolis soils"
# tabledata$Soil_Type[2] <- "Annapolis fine sandy loam"
# tabledata$Soil_Type[3] <- "Collington and Annapolis soils; Collington, Wist, and Westphalia soils"

tabledata %>% 
  unite(col = 'Trees (/ha)', tree_mean, tree_sd, sep = " ± ") %>%
  unite(col = 'BA (m2/ha)', BA_mean, BA_sd, sep = " ± ") %>%
  knitr::kable(digits = 1, format = "html", 
               col.names = c("Site", "Salinity", "Trees (/ha)", expression(BA~(m^2~ha^-1)))) %>%
  kableExtra::kable_styling(c("striped", "bordered"), full_width = FALSE)

```


### Flux over time figure for control collars
```{r co2_time, echo = FALSE, warning = FALSE}
licor_daily_data <- readd("licor_daily_data")

# s.d. is based on successive measurements at same collar
licor_daily_data %>% 
  filter(!is.na(meanFlux), !is.na(sdFlux)) %>% 
  filter(Group == "Control") %>%
  ggplot(aes(x = Timestamp, y = meanFlux, group = Collar, color = Collar)) +
  geom_errorbar(aes(ymin = meanFlux - sdFlux, ymax = meanFlux + sdFlux), color = "tomato3") +
  geom_line(size = 1, color = "tomato3") +
  geom_point(color = "tomato3") +
  #scale_colour_gradientn(colours = rainbow(4)) +
  facet_grid(Dest_Elevation ~ Dest_Salinity) +
  ggtitle("Flux over time") +
  labs(x = "Date", 
       y = expression(Flux~(µmol~CO[2]~m^-2~s^-1))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


### Hypothesis I - BA strong effect within 5 meters
```{r, echo = FALSE, warning = FALSE}
# Filter Licor data for only true control collars and screen out bad SM data
MODEL_TYPE <- "linear"

readd("licor_data") %>% 
  filter(Experiment == "Control", is.na(Notes)) %>% 
  # Filter out bad soil moisture and flux readings
  filter(SMoisture > 0, SMoisture < 1,
         Flux > 0) ->
  control_cols

# Calculate basal area within 5 m
BA5 <- basal_area_sum(tree_prox_data, distance = 5)

# Join the respiration data with the BA proximity data; this is main analysis dataset
control_cols %>% 
  left_join(BA5, by = "Collar") %>% 
  mutate(Timestamp = ymd_hms(Timestamp)) -> 
  control_cols_5m

# Run the main analysis
h1 <- with(control_cols_5m, run_model(Flux, T5, T20, SMoisture, BA_m2, site = Dest_Salinity, model_type = MODEL_TYPE))

# model_stats(h1)

```


### Table 2
```{r, echo = FALSE, warning = FALSE, message = FALSE}

# print(MODEL_TYPE)
# knitr::kable(tidy(anova(m_reduced)), digits = 3, format = "html") %>%
#   kableExtra::kable_styling(c("striped", "bordered"), full_width = FALSE)

```


### Hypothesis II - growing vs. dormant season
```{r, echo = FALSE, warning = FALSE}
# Filter true controls for growing season
print(summary(control_cols_5m$Timestamp))
GS_MONTHS <- 4:10  # growing season months, i.e. April-October
control_cols_5m$Growing_season <- month(control_cols_5m$Timestamp) %in% GS_MONTHS

growing_flux <- filter(control_cols_5m, Growing_season)
h2g <- with(growing_flux, run_model(Flux, T5, T20, SMoisture, BA_m2, 
                                     site = Dest_Salinity, model_type = MODEL_TYPE))

# model_stats(h2g)

# Filter true controls for dormant season
dormant_flux <- filter(control_cols_5m, !Growing_season)
print(dormant_flux)
h2d <- with(dormant_flux, run_model(Flux, T5, T20, SMoisture, BA_m2, 
                                     site = Dest_Salinity, model_type = MODEL_TYPE))

# model_stats(h2d)

```

### Hypothesis III - moisture-limited times
```{r, echo = FALSE, warning = FALSE}

## replace with actual variable name once drake is working
smoisture_median <- median(control_cols_5m$SMoisture)

# Filter true controls for the bottom and top 50% soil moisture values; this will be our "limited" and "ample" moisture times
m_low <- filter(control_cols_5m, SMoisture < smoisture_median)
print(m_low)
h3l <- with(m_low, run_model(Flux, T5, T20, SMoisture, BA_m2, site = Dest_Salinity, model_type = MODEL_TYPE))

# model_stats(h3l)

m_high <- filter(control_cols_5m, SMoisture >= smoisture_median)
print(m_high)
h3a <- with(m_high, run_model(Flux, T5, T20, SMoisture, BA_m2, site = Dest_Salinity, model_type = MODEL_TYPE))
 
# model_stats(h3a)

```

### Sensitivity test - BA significance with distance
```{r, echo = FALSE, warning = FALSE, fig.width = 9}

sens_output <- list()
BA_output <- list()
# Loop through the range of distances we measured and run 
# our basal area/respiration test at each
for (i in seq.int(2, max(tree_prox_data$Distance_m))) {
  BA <- basal_area_sum(tree_prox_data, i)
  data <- left_join(control_cols, BA, by = "Collar") %>%
    select(Collar, Flux, T5, T20, SMoisture, BA_m2, Dest_Salinity)  # select just columns we want 
  mods <- with(data, run_model(Flux, T5, T20, SMoisture, BA_m2, 
                                site = Dest_Salinity, model_type = MODEL_TYPE))
  model <- mods$reduced_model
  smry <- anova(model)
  smry$term = rownames(smry)
  
  # linear and lme models return differently-named p-value columns, which isn't handy
  if("Pr(>F)" %in% colnames(smry)) {
    smry <- rename(smry, `p-value` = `Pr(>F)`)
  }
  
  ichar <- as.character(i)
  sens_output[[ichar]] <- as_tibble(smry)
}

bind_rows(sens_output, .id = "Distance") %>%
  filter(term == "BA") %>%
  mutate(Distance = as.integer(Distance)) %>%
  print %>%
  ggplot(aes(Distance, `p-value`)) + 
  geom_line(size = 1, color = "grey") + 
  geom_point(size = 2.5, color = "tomato3") +
  geom_hline(yintercept = 0.05, linetype = 2) +
  ggtitle(paste("Basal Area Significance -", MODEL_TYPE)) +
  xlab("Radial distance from collar (in meters)") + 
  ylab("P-value for test of BA significance to flux")

```
