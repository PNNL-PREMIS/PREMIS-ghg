---
title: "proximity_results"
author: "SP"
date: "October 24, 2018"
output: html_document
---

```{r helper-functions, echo = FALSE, warning = FALSE, message = FALSE, results = 'hide'}

library(MASS)
library(nlme) # 3.1.137
#library(lme4) # 1.1-19
library(drake)
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())
library(broom)
library(lubridate)
library(piecewiseSEM)

# Define functions

# Calcuate basal area (m2) from tree diameter (cm)
calc_BA <- function(DBH) {
  DBH_m <- DBH / 100 # cm to meters
  radius <- DBH_m / 2 # we want the radius to compute the area
  radius ^ 2 * pi # basal area area calculation
}

# Compute the sum of per-tree basal area within a certain distance (to respiration collars)
basal_area_sum <- function(data, distance) {
  data %>% 
    filter(Distance_m <= distance) %>% 
    group_by(Collar) %>% 
    summarise(n_trees = n(), 
              BA_m2 = round(sum(BA_sqm, na.rm = TRUE), digits = 3), 
              dist = distance) %>% 
    replace_na(list(n_trees = 0, BA_m2 = 0.0))  # if no trees within distance, zero
}

# Fit the main statistical model testing for effect of basal area (BA) on soil respiration
run_model <- function(dat, model_type) {
  
  if(any(is.na(dat))) {
    stop("Can't have any NAs in run_model data")
  }

  if(model_type == "linear") {
    mod_full <- lm(log(Flux) ~ T5 * BA_m2 + T20 * BA_m2 + SMoisture + I(SMoisture ^ 2),
                   data = dat)
    mod_no_BA <- lm(formula = log(Flux) ~ T5 + T20 + SMoisture + I(SMoisture ^ 2), data = dat)
  } else if(model_type == "lme") {
    mod_full <- nlme::lme(log(Flux) ~ T5 * BA_m2 + T20 * BA_m2 + SMoisture + I(SMoisture ^ 2),
                          data = dat,
                          # allow for random variation across sites
                          random = ~ 1 | Site,
                          method = "ML") # because we're doing stepAIC below
    mod_no_BA <- nlme::lme(log(Flux) ~ T5 + T20 + SMoisture + I(SMoisture ^ 2),
                           data = dat, random = ~ 1 | Site, method = "ML")
  } else {
    stop("Unknown model type ", model_type)
  }
  
  # Remove non-significant variables and return
  mod_reduced <- stepAIC(mod_full, direction = "both", trace = 0)
  list(full_model = mod_full, reduced_model = mod_reduced, mod_no_BA = mod_no_BA)
}

# Produce summaries and plots for the run_model() objects
model_stats <- function(mods, dat) {
  
  print(piecewiseSEM::rsquared(mods$full_model))
  
  # Plot correlation between BA and the residuals of the model
  # WITHOUT basal area included
  dat$no_BA_residuals <- residuals(mods$mod_no_BA)
  p <- ggplot(dat, aes(no_BA_residuals, BA_m2)) + 
    geom_point(aes(color = Site)) + geom_smooth(method = "lm")
  print(p)
  
  m_reduced <- mods$reduced_model
  
  print(summary(m_reduced))
  print(anova(m_reduced))
  plot(m_reduced)
}
```


```{r setup, echo = FALSE}

tree_data <- readd("tree_data")
prox_data <- readd("prox_data")

prox_data %>%
  select(-Date) %>% 
  left_join(tree_data, by = c("Site", "Plot", "Tag"), na_matches = "never") %>%
  # Replace DBH with recorded value for non-tagged trees
  mutate(DBH_cm = if_else(is.na(Tag), No_tag_DBH, DBH_cm),
         Species_code = if_else(is.na(Tag), No_tag_species, Species_code),
         BA_sqm = calc_BA(DBH_cm)) -> # Compute basal area for each tree
  tree_prox_data

```


### Prep work: compute cumulative basal area for each collar
```{r basal-area-fig, fig.width = 9, echo = FALSE}

# Calculate cumulative basal area at each distance 
BA_dat <- list()
for (i in 1:max(tree_prox_data$Distance_m, na.rm = TRUE)) {
  tree_prox_data %>% 
    filter(Distance_m <= i) %>% 
    group_by(Collar) %>% 
    summarise(n_trees = n(), 
              BA_m2 = sum(BA_sqm, na.rm = TRUE), 
              dist = i) -> #%>%
    #    complete(dist = i, Collar, fill = list(BA_m2 = 0, n_trees = 0))->
    BA_dat[[i]]
}

# Combine and complete data (in particular, adding values for 0 m)
bind_rows(BA_dat) %>% 
  complete(Collar, dist = c(0:max(tree_prox_data$Distance_m, na.rm = TRUE)),
           fill = list(BA_m2 = 0, n_trees = 0)) ->
  BA_dat_complete

# ...and plot
BA_dat_complete %>% 
  ggplot(aes(x = dist, y = BA_m2, group = Collar, color = n_trees)) + 
  geom_line(size = 1) +
  scale_colour_gradientn(colours = topo.colors(9)) +
  ggtitle("Figure 2") +
  labs(x = "Radial distance from collar (m)", 
       y = expression(Basal~Area~(m^2)), 
       color = "Number \nof Trees")

```


## Table 1 - site info
```{r site-info, echo = FALSE, warning = FALSE, message = FALSE}
# BA by percentage
tree_data %>%
  group_by(Site, Salinity, Species) %>%
  summarise(n = n(),
            BA_species = sum(calc_BA(DBH_cm), na.rm = TRUE)) %>%
  mutate(BA_p = BA_species/sum(BA_species) * 100) ->
  BA_p

##SP TO ADD COMMENTS AND CONSTANTS FOR CLARITY
tree_data %>% 
  group_by(Salinity, Elevation) %>% 
  summarise(n = n(), 
            Plot_area_m2 = mean(Plot_area_m2), 
            `BA (m2/ha)` = sum(calc_BA(DBH_cm), na.rm = TRUE) / 
              mean(Plot_area_m2) * 10000) %>% 
  mutate(`Trees (/ha)` = n / Plot_area_m2 * 10000) %>% 
  summarise(tree_mean = mean(`Trees (/ha)`) %>% round(1), 
            tree_sd = sd(`Trees (/ha)`) %>% round(1), 
            BA_mean = mean(`BA (m2/ha)`) %>% round(1), 
            BA_sd = sd(`BA (m2/ha)`) %>% round(1)) ->
  tabledata

# Site info
tabledata$tree_mean <- round(tabledata$tree_mean, digits = 1)
tabledata$tree_sd <- round(tabledata$tree_sd, digits = 1)
tabledata$BA_mean <- round(tabledata$BA_mean, digits = 1)
tabledata$BA_sd <- round(tabledata$BA_sd, digits = 1)
tabledata$Salinity <- sub("Salinity H", "GCREW", tabledata$Salinity)
tabledata$Salinity <- sub("Salinity M", "Canoe Shed", tabledata$Salinity)
tabledata$Salinity <- sub("Salinity L", "North Branch", tabledata$Salinity)
# tabledata$Soil_Type[1] <- "Collington-Wist complex; Collington and Annapolis soils"
# tabledata$Soil_Type[2] <- "Annapolis fine sandy loam"
# tabledata$Soil_Type[3] <- "Collington and Annapolis soils; Collington, Wist, and Westphalia soils"

tabledata %>% 
  unite(col = 'Trees (/ha)', tree_mean, tree_sd, sep = " ± ") %>%
  unite(col = 'BA (m2/ha)', BA_mean, BA_sd, sep = " ± ") %>%
  knitr::kable(digits = 1, format = "html", 
               col.names = c("Site", "Trees (/ha)", "BA (m2/ha)")) %>%
  kableExtra::kable_styling(c("striped", "bordered"), full_width = FALSE)

```


## Flux over time figure for control collars
```{r co2_time, echo = FALSE, warning = FALSE}
licor_daily_data <- readd("licor_daily_data")

# Mapping for 
nicenames <- c("High" = "GCREW", "Medium" = "Canoe Shed", "Low" = "North Branch")

# s.d. is based on successive measurements at same collar
licor_daily_data %>% 
  mutate(nicename = factor(nicenames[Dest_Salinity], levels = nicenames)) %>% 
  filter(!is.na(meanFlux), !is.na(sdFlux)) %>% 
  filter(Group == "Control") %>%
  ggplot(aes(x = Timestamp, y = meanFlux, group = Collar)) +
  #geom_errorbar(aes(ymin = meanFlux - sdFlux, ymax = meanFlux + sdFlux)) +
  geom_point() +
  facet_grid(~nicename) + #need to rename to site names
  ggtitle("Figure 3") +
  labs(x = "Date", 
       y = expression(Flux~(µmol~CO[2]~m^-2~s^-1))) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

## Model Results {.tabset .tabset-fade .tabset-pills}

### Hypothesis I - BA strong effect within 5 meters 
```{r test-h1, echo = FALSE, warning = FALSE}
# Filter Licor data for only true control collars and screen out bad SM data
MODEL_TYPE <- "lme"

readd("licor_data") %>% 
  filter(Experiment == "Control", is.na(Notes)) %>% 
  # Filter out bad soil moisture and flux readings
  filter(SMoisture > 0, SMoisture < 1,
         Flux > 0) ->
  control_cols

# Calculate basal area within 5 m
BA5 <- basal_area_sum(tree_prox_data, distance = 5)

filter_NAs <- function(x) {
  x %>% filter(!is.na(Flux), !is.na(T5), !is.na(T20), !is.na(SMoisture), !is.na(BA_m2))
}

# Join the respiration data with the BA proximity data; this is main analysis dataset
control_cols %>% 
  left_join(BA5, by = "Collar") %>% 
  mutate(Timestamp = ymd_hms(Timestamp)) %>% 
  select(Timestamp, Flux, T5, T20, SMoisture, BA_m2, Site = Dest_Salinity) %>% 
  na.omit -> 
  control_cols_5m

# Run the main analysis
h1 <- run_model(control_cols_5m, model_type = MODEL_TYPE)

model_stats(h1, control_cols_5m)

```

### Hypothesis II - growing vs. dormant season
```{r test-h2, echo = FALSE, warning = FALSE}
# Filter true controls for growing season
GS_MONTHS <- 4:10  # growing season months, i.e. April-October
control_cols_5m$Growing_season <- month(control_cols_5m$Timestamp) %in% GS_MONTHS

growing_flux <- filter(control_cols_5m, Growing_season)
h2g <- run_model(growing_flux, model_type = MODEL_TYPE)
print("Growing Season")
model_stats(h2g, growing_flux)

# Filter true controls for dormant season
dormant_flux <- filter(control_cols_5m, !Growing_season)
h2d <- run_model(dormant_flux, model_type = MODEL_TYPE)

print("Dormant Season")
model_stats(h2d, dormant_flux)

```

### Hypothesis III - moisture-limited times
```{r test-h3, echo = FALSE, warning = FALSE}

## replace with actual variable name once drake is working
control_cols_5m$SM_bin <- cut(control_cols_5m$SMoisture, breaks = 3, label = FALSE)

low_i <- which(control_cols_5m$SM_bin == 1)

## Filter true controls for the bottom and top 33% soil moisture values
m_low <- control_cols_5m[low_i, ] %>% filter_NAs
h3l <- run_model(m_low, model_type = MODEL_TYPE)

print("Low Moisture")
model_stats(h3l, m_low)

high_i <- which(control_cols_5m$SM_bin == 3)
m_high <- control_cols_5m[high_i, ] %>% filter_NAs
h3h <- run_model(m_high, model_type = MODEL_TYPE)

print("High Moisture")
model_stats(h3h, m_high)
```

### Sensitivity test - BA significance with distance
```{r sensitivity, echo = FALSE, warning = FALSE, fig.width = 9}

sens_output <- list()
BA_output <- list()
# Loop through the range of distances we measured and run 
# our basal area/respiration test at each
for (i in seq.int(2, max(tree_prox_data$Distance_m, na.rm = TRUE))) {
  BA <- basal_area_sum(tree_prox_data, i)
  control_cols %>% 
    left_join(BA, by = "Collar") %>%
    select(Timestamp, Flux, T5, T20, SMoisture, BA_m2, Site = Dest_Salinity) %>% 
    na.omit ->
    dat
  mods <- run_model(dat, model_type = MODEL_TYPE)
  model <- mods$reduced_model
  smry <- anova(model)
  smry$term = rownames(smry)
  
  # linear and lme models return differently-named p-value columns, which isn't handy
  if("Pr(>F)" %in% colnames(smry)) {
    smry <- rename(smry, `p-value` = `Pr(>F)`)
  }
  
  sens_output[[as.character(i)]] <- as_tibble(smry)
}

bind_rows(sens_output, .id = "Distance") %>%
  filter(term == "BA_m2") %>%
  mutate(Distance = as.integer(Distance)) %>%
  print %>%
  ggplot(aes(Distance, `p-value`)) + 
  geom_line(size = 1, color = "grey") + 
  geom_point(size = 2.5, color = "tomato3") +
  geom_hline(yintercept = 0.05, linetype = 2) +
  ggtitle(paste("Basal Area Significance -", MODEL_TYPE)) +
  xlab("Radial distance from collar (in meters)") + 
  ylab("P-value for test of BA significance to flux")
```
